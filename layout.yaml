layouts:
  - path: main.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator, Customize by suyiiyii at https://github.com/suyiiyii/cwgo-template/tree/hertz

      package main

      import (
        "context"
      	"os"

        "github.com/cloudwego/hertz/pkg/app"
      	"github.com/cloudwego/hertz/pkg/app/middlewares/server/recovery"
      	"github.com/cloudwego/hertz/pkg/app/server"
      	"github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/hertz-contrib/cors"
      	"github.com/hertz-contrib/gzip"
        "github.com/hertz-contrib/logger/accesslog"
      	hertzlogrus "github.com/hertz-contrib/logger/logrus"
      	"github.com/hertz-contrib/pprof"
      	"{{.GoModule}}/biz/router"
      	"{{.GoModule}}/conf"
      )

      func main() {
        // use `go run cmd/gorm/main.go` to migrate the database
        // dal.Init()
        // use `go run cmd/gorm_gen/main.go` to generate the code
        // query.SetDefault(mysql.DB)
      	address := conf.GetConf().Hertz.Address
      	h := server.New(server.WithHostPorts(address))

        registerMiddleware(h)

        // add a ping route to test
        h.GET("/ping", func(c context.Context, ctx *app.RequestContext) {
        	ctx.JSON(consts.StatusOK, utils.H{"ping": "pong"})
        })

      	router.GeneratedRegister(h)

      	h.Spin()
      }

      func registerMiddleware(h *server.Hertz) {
      	// log
      	logger := hertzlogrus.NewLogger()
      	hlog.SetLogger(logger)
      	hlog.SetLevel(conf.LogLevel())
        hlog.SetOutput(os.Stdout)

      	// pprof
      	if conf.GetConf().Hertz.EnablePprof {
      		pprof.Register(h)
      	}

      	// gzip
      	if conf.GetConf().Hertz.EnableGzip {
      		h.Use(gzip.Gzip(gzip.DefaultCompression))
      	}

        // access log
        if conf.GetConf().Hertz.EnableAccessLog {
          h.Use(accesslog.New())
        }

        // recovery
        h.Use(recovery.Recovery())

         // cores
        h.Use(cors.Default())
      }

  - path: go.mod
    delims:
      - "{{"
      - "}}"
    body: |-
      module {{.GoModule}}
      {{- if .UseApacheThrift}}
      replace github.com/apache/thrift => github.com/apache/thrift v0.13.0
      {{- end}}

  - path: biz/router/register.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator. DO NOT EDIT.

      package router

      import (
      	"github.com/cloudwego/hertz/pkg/app/server"
      )

      // GeneratedRegister registers routers generated by IDL.
      func GeneratedRegister(r *server.Hertz){
      	//INSERT_POINT: DO NOT DELETE THIS LINE!
      }

  - path: conf/conf.go
    delims:
      - ""
      - ""
    body: |-
      package conf

      import (
        "bytes"
        _ "embed"
        "strings"
        "sync"

        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/joho/godotenv"
        "github.com/kr/pretty"
        "github.com/spf13/viper"
        "gopkg.in/validator.v2"
      )

      var (
        //go:embed conf.yaml
        configFile []byte
        conf       *Config
        once       sync.Once
      )

      type Config struct {
        Hertz struct {
          Address         string `mapstructure:"address"`
          Service         string `mapstructure:"service"`
          EnablePprof     bool   `mapstructure:"enable_pprof"`
          EnableGzip      bool   `mapstructure:"enable_gzip"`
          EnableAccessLog bool   `mapstructure:"enable_access_log"`
          LogLevel        string `mapstructure:"log_level"`
          OtlpAddr        string `mapstructure:"otlp_address"`
        } `mapstructure:"hertz"`

        Registry struct {
          RegistryAddress []string `mapstructure:"registry_address"`
          Username        string   `mapstructure:"username"`
          Password        string   `mapstructure:"password"`
        } `mapstructure:"registry"`

        MySQL struct {
          Host     string `mapstructure:"host"`
          Port     string `mapstructure:"port"`
          Username string `mapstructure:"username"`
          Password string `mapstructure:"password"`
        } `mapstructure:"mysql"`

        Redis struct {
          Address  string `mapstructure:"address"`
          Password string `mapstructure:"password"`
          Username string `mapstructure:"username"`
          DB       int    `mapstructure:"db"`
        } `mapstructure:"redis"`
      }

      // GetConf gets configuration instance
      func GetConf() *Config {
        once.Do(initConf)
        return conf
      }

      func initConf() {
        // Load .env file
        err := godotenv.Load()
        if err != nil {
          hlog.Warn("Error loading .env file")
        }

        conf = new(Config)
        viper.SetConfigType("yaml")
        err = viper.ReadConfig(bytes.NewBuffer(configFile))
        if err != nil {
          panic(err)
        }

        // Enable automatic environment variable reading
        viper.SetEnvPrefix("APP")
        viper.AutomaticEnv()
        viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

        err = viper.Unmarshal(conf)
        if err != nil {
          panic(err)
        }

        if err := validator.Validate(conf); err != nil {
          hlog.Error("validate config error - %v", err)
          panic(err)
        }

        pretty.Printf("%+v\n", conf)
      }

      func LogLevel() hlog.Level {
        level := GetConf().Hertz.LogLevel
        switch level {
        case "trace":
          return hlog.LevelTrace
        case "debug":
          return hlog.LevelDebug
        case "info":
          return hlog.LevelInfo
        case "notice":
          return hlog.LevelNotice
        case "warn":
          return hlog.LevelWarn
        case "error":
          return hlog.LevelError
        case "fatal":
          return hlog.LevelFatal
        default:
          return hlog.LevelInfo
        }
      }

  - path: conf/conf.yaml
    delims:
      - ""
      - ""
    body: |-
      # Hertz HTTP Server Configuration
      hertz:
        address: ":8080"
        service: "{{.ServiceName}}"
        enable_pprof: true
        enable_gzip: true
        enable_access_log: true
        log_level: "info"
        otlp_address: "localhost:4317"

      # Service Registry Configuration
      registry:
        registry_address: 
          - "localhost:2379"
        username: ""
        password: ""

      # MySQL Database Configuration
      mysql:
        host: "localhost"
        port: "3306"
        username: "root"
        password: "password"

      # Redis Configuration
      redis:
        address: "localhost:6379"
        password: ""
        username: ""
        db: 0

  - path: biz/dal/init.go
    delims:
      - ""
      - ""
    body: |-
      package dal

      import (
      	"{{.GoModule}}/biz/dal/mysql"
      	"{{.GoModule}}/biz/dal/redis"
      )

      func Init() {
      	redis.Init()
      	mysql.Init()
      }

  - path: biz/dal/mysql/init.go
    delims:
      - ""
      - ""
    body: |-
      package mysql

      import (
      	"{{.GoModule}}/conf"
        "fmt"
      	"gorm.io/driver/mysql"
      	"gorm.io/gorm"
      )

      var (
        DB  *gorm.DB
        err error
        c   = conf.GetConf()
      )

      func Init() {
        dsn := "%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local"

        DB, err = gorm.Open(mysql.Open(fmt.Sprintf(dsn, c.MySQL.Username, c.MySQL.Password, c.MySQL.Host, c.MySQL.Port, c.Hertz.Service)),
          &gorm.Config{
            PrepareStmt:            true,
            SkipDefaultTransaction: true,
          },
        )
        if err != nil {
          panic(err)
        }
      }


  - path: biz/dal/redis/init.go
    delims:
      - ""
      - ""
    body: |-
      package redis

      import (
      	"context"

      	"github.com/redis/go-redis/v9"
      	"{{.GoModule}}/conf"
      )

      var RedisClient *redis.Client

      func Init() {
      	RedisClient = redis.NewClient(&redis.Options{
      		Addr:     conf.GetConf().Redis.Address,
      		Username: conf.GetConf().Redis.Username,
      		Password: conf.GetConf().Redis.Password,
      		DB:       conf.GetConf().Redis.DB,
      	})
      	if err := RedisClient.Ping(context.Background()).Err(); err != nil {
      		panic(err)
      	}
      }

  - path: docker-compose.yaml
    delims:
      - ""
      - ""
    body: |-
      version: '3'
      services:
        mysql:
          image: 'mysql:latest'
          ports:
            - 3306:3306
          environment:
            - MYSQL_DATABASE=gorm
            - MYSQL_USER=gorm
            - MYSQL_PASSWORD=gorm
            - MYSQL_RANDOM_ROOT_PASSWORD="yes"
        redis:
          image: 'redis:latest'
          ports:
            - 6379:6379

  - path: readme.md
    delims:
      - ""
      - ""
    body: |-
      # *** Project

      ## introduce

      - Use the [Hertz](https://github.com/cloudwego/hertz/) framework
      - Integration of pprof, cors, recovery, access_log, gzip and other extensions of Hertz.
      - Generating the base code for unit tests.
      - Provides basic profile functions.
      - Provides the most basic MVC code hierarchy.

      ## Directory structure

      |  catalog   | introduce  |
      |  ----  | ----  |
      | conf  | Configuration files |
      | main.go  | Startup file |
      | hertz_gen  | Hertz generated model |
      | biz/handler  | Used for request processing, validation and return of response. |
      | biz/service  | The actual business logic. |
      | biz/dal  | Logic for operating the storage layer |
      | biz/route  | Routing and middleware registration |
      | biz/utils  | Wrapped some common methods |

      ## How to run

      ```shell
      sh build.sh
      sh output/bootstrap.sh
      ```

  - path: .gitignore
    delims:
      - ""
      - ""
    body: |-
      *.o
      *.a
      *.so
      _obj
      _test
      *.[568vq]
      [568vq].out
      *.cgo1.go
      *.cgo2.c
      _cgo_defun.c
      _cgo_gotypes.go
      _cgo_export.*
      _testmain.go
      *.exe
      *.exe~
      *.test
      *.prof
      *.rar
      *.zip
      *.gz
      *.psd
      *.bmd
      *.cfg
      *.pptx
      *.log
      *nohup.out
      *settings.pyc
      *.sublime-project
      *.sublime-workspace
      !.gitkeep
      .DS_Store
      /.idea
      /.vscode
      /output
      *.local.yml
      .env

  - path: biz/utils/resp.go
    delims:
      - "{{"
      - "}}"
    body: |-
      package utils

      import (
      	"context"

      	"github.com/cloudwego/hertz/pkg/app"
      )

      type ErrResponse struct {
        Success  bool
        Code     int
        ErrorMsg string
      }

      // SendErrResponse  pack error response
       func SendErrResponse(ctx context.Context, c *app.RequestContext, code int, err error) {
        // todo edit custom code
        c.JSON(code, ErrResponse{Success: false, Code: code, ErrorMsg: err.Error()})
      }

      // SendSuccessResponse  pack success response
      func SendSuccessResponse(ctx context.Context, c *app.RequestContext, code int, data interface{}) {
      	// todo edit custom code
      	c.JSON(code, data)
      }

  - path: build.sh
    delims:
      - "{{"
      - "}}"
    body: |-
      #!/bin/bash
      RUN_NAME={{.ServiceName}}
      mkdir -p output/bin output/conf
      cp script/bootstrap.sh output 2>/dev/null
      chmod +x output/bootstrap.sh
      cp -r conf/* output/conf
      go build -o output/bin/${RUN_NAME}

  - path: script/bootstrap.sh
    delims:
      - "{{"
      - "}}"
    body: |-
      #!/bin/bash
      CURDIR=$(cd $(dirname $0); pwd)
      BinaryName={{.ServiceName}}
      echo "$CURDIR/bin/${BinaryName}"
      exec $CURDIR/bin/${BinaryName}
  - path: biz/dal/model/model.go
    update_behavior:
      type: skip
    body: |-
      package model
      
      import (
        "gorm.io/gorm"
      )
      
      // rename to create your own model
      type User struct {
        gorm.Model
        UserId    uint32 `gorm:"type:int(11);not null;index"`
      }
      
      // Querier is the interface for the query, you can implement it with your own query logic
      type Querier interface {
        // GetByUserId get user by user id
        //
        // SELECT * FROM @@table WHERE user_id = @userId and deleted_at is null
        GetByUserId(userId uint32) ([]*User, error)
      }
  
  - path: cmd/gorm/main.go
    body: |-
      package main

      import (
        "fmt"
      
        "{{.GoModule}}/biz/dal/model"
        "{{.GoModule}}/biz/dal/mysql"
        "{{.GoModule}}/conf"
      
      	"github.com/cloudwego/hertz/pkg/common/hlog"
        mysqldb "gorm.io/driver/mysql"
        "gorm.io/gorm"
      )
      
      var c = conf.GetConf()
        
      func main() {
        // connect to mysql manually to check and create database
        dsn := "%s:%s@tcp(%s:%s)/?charset=utf8mb4&parseTime=True&loc=Local"
        db, err := gorm.Open(mysqldb.Open(fmt.Sprintf(dsn, c.MySQL.Username, c.MySQL.Password, c.MySQL.Host, c.MySQL.Port)),
          &gorm.Config{
            PrepareStmt:            true,
            SkipDefaultTransaction: true,
          },
        )
        if err != nil {
          panic(err)
        }

        var count int
        dbName := conf.GetConf().Hertz.Service
        db.Raw("SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = ?", dbName).Scan(&count)
        if count == 0 {
          hlog.Warn("Database not found, creating database")
          db.Exec(fmt.Sprintf("CREATE DATABASE `%s`", dbName))
        }

        // migrate the database
        mysql.Init()

        err = mysql.DB.Set("gorm:table_options", "CHARSET=utf8mb4").AutoMigrate(&model.User{})
        if err != nil {
          panic(err)
        }
      }
  - path: cmd/gorm_gen/main.go
    update_behavior:
      type: skip
    body: |-
      package main
      
      import (
        "{{.GoModule}}/biz/dal/model"
      
        "gorm.io/gen"
      )
      
      func main() {
        
        g := gen.NewGenerator(gen.Config{
        OutPath: "biz/dal/query",
        Mode:    gen.WithoutContext | gen.WithDefaultQuery | gen.WithQueryInterface,
        })
        
        g.ApplyInterface(func(model.Querier) {}, model.User{})
        g.Execute()
      }

  - path: Dockerfile
    update_behavior:
      type: skip
    body: |-
      # syntax=docker/dockerfile:1

      # Comments are provided throughout this file to help you get started.
      # If you need more help, visit the Dockerfile reference guide at
      # https://docs.docker.com/go/dockerfile-reference/

      # Want to help us make this template better? Share your feedback here: https://forms.gle/ybq9Krt8jtBL3iCk7

      ################################################################################
      # Create a stage for building the application.
      ARG GO_VERSION=1.23.4
      FROM --platform=$BUILDPLATFORM golang:${GO_VERSION} AS build
      WORKDIR /src

      # Download dependencies as a separate step to take advantage of Docker's caching.
      # Leverage a cache mount to /go/pkg/mod/ to speed up subsequent builds.
      # Leverage bind mounts to go.sum and go.mod to avoid having to copy them into
      # the container.
      RUN --mount=type=cache,target=/go/pkg/mod/ \
          --mount=type=bind,source=go.sum,target=go.sum \
          --mount=type=bind,source=go.mod,target=go.mod \
          go mod download -x

      # This is the architecture you're building for, which is passed in by the builder.
      # Placing it here allows the previous steps to be cached across architectures.
      ARG TARGETARCH

      # Build the application.
      # Leverage a cache mount to /go/pkg/mod/ to speed up subsequent builds.
      # Leverage a bind mount to the current directory to avoid having to copy the
      # source code into the container.
      RUN --mount=type=cache,target=/go/pkg/mod/ \
          --mount=type=bind,target=. \
          CGO_ENABLED=0 GOARCH=$TARGETARCH go build -o /bin/server .

      ################################################################################
      # Create a new stage for running the application that contains the minimal
      # runtime dependencies for the application. This often uses a different base
      # image from the build stage where the necessary files are copied from the build
      # stage.
      #
      # The example below uses the alpine image as the foundation for running the app.
      # By specifying the "latest" tag, it will also use whatever happens to be the
      # most recent version of that image when you build your Dockerfile. If
      # reproducability is important, consider using a versioned tag
      # (e.g., alpine:3.17.2) or SHA (e.g., alpine@sha256:c41ab5c992deb4fe7e5da09f67a8804a46bd0592bfdf0b1847dde0e0889d2bff).
      FROM debian:12-slim AS final

      # Create a non-privileged user that the app will run under.
      # See https://docs.docker.com/go/dockerfile-user-best-practices/
      ARG UID=10001
      RUN adduser \
          --disabled-password \
          --gecos "" \
          --home "/nonexistent" \
          --shell "/sbin/nologin" \
          --no-create-home \
          --uid "${UID}" \
          appuser
      USER appuser

      # Copy the executable from the "build" stage.
      COPY --from=build /bin/server /bin/

      # Expose the port that the application listens on.
      EXPOSE 8080

      # What the container should run when it is started.
      ENTRYPOINT [ "/bin/server" ]